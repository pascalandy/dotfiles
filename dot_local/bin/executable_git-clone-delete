#!/usr/bin/env bash
#
# ==============================================================================
# git-clone-delete - Safely remove a cloned repo directory
# ==============================================================================
# Removes a git clone with safety checks for uncommitted changes and
# unpushed commits. Uses gum for interactive confirmations.
# Outputs "deleted" on success for the calling wrapper to handle cd.
# ==============================================================================

readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_AUTHOR="Pascal Andy"
readonly SCRIPT_DESCRIPTION="Safely remove a cloned repo directory."

readonly SCRIPT_NAME="${BASH_SOURCE[0]##*/}"

# ==============================================================================
# Runtime options
# ==============================================================================

VERBOSE=0
DRY_RUN=0
NO_COLOR="${NO_COLOR:-}"
FORCE=0

# ==============================================================================
# Strict mode
# ==============================================================================

set -euo pipefail

# ==============================================================================
# Logging (to stderr so stdout can be used for status)
# ==============================================================================

fct_ansi() {
	local code="${1}"
	if [[ -t 2 && -z "${NO_COLOR}" ]]; then
		printf '\033[%sm' "${code}"
	fi
}

log_info() {
	local reset="" prefix=""
	if [[ -t 2 && -z "${NO_COLOR}" ]]; then
		prefix="$(fct_ansi '32')"
		reset="$(fct_ansi '0')"
	fi
	printf '%s%s%s\n' "${prefix}" "$*" "${reset}" >&2
}

log_warn() {
	local reset="" prefix=""
	if [[ -t 2 && -z "${NO_COLOR}" ]]; then
		prefix="$(fct_ansi '33')"
		reset="$(fct_ansi '0')"
	fi
	printf '%s%s%s\n' "${prefix}" "$*" "${reset}" >&2
}

log_error() {
	local reset="" prefix=""
	if [[ -t 2 && -z "${NO_COLOR}" ]]; then
		prefix="$(fct_ansi '31')"
		reset="$(fct_ansi '0')"
	fi
	printf '%s%s%s\n' "${prefix}" "$*" "${reset}" >&2
}

log_debug() {
	if [[ "${VERBOSE}" -eq 1 ]]; then
		local reset="" prefix=""
		if [[ -t 2 && -z "${NO_COLOR}" ]]; then
			prefix="$(fct_ansi '36')"
			reset="$(fct_ansi '0')"
		fi
		printf '%s[DEBUG] %s%s\n' "${prefix}" "$*" "${reset}" >&2
	fi
}

# ==============================================================================
# Usage
# ==============================================================================

usage() {
	cat <<EOF
${SCRIPT_NAME} v${SCRIPT_VERSION}
${SCRIPT_DESCRIPTION}
Author: ${SCRIPT_AUTHOR}

Usage:
  ${SCRIPT_NAME} [options]

Options:
  -h, --help       Show this help and exit
  -V, --version    Show version and exit
  -v, --verbose    Enable debug logging
  -n, --dry-run    Show what would be done without executing
  -f, --force      Skip confirmation prompts
      --no-color   Disable colored output

Description:
  Run from within the clone you want to delete.
  Checks for uncommitted changes and unpushed commits before deleting.
  Uses gum for interactive confirmations (requires gum to be installed).

  Outputs "deleted" to stdout on success for wrapper function to handle cd.

Examples:
  ${SCRIPT_NAME}           # Interactive mode with confirmations
  ${SCRIPT_NAME} -f        # Force delete without prompts
  ${SCRIPT_NAME} -n        # Dry run - show what would happen
EOF
}

# ==============================================================================
# Argument parsing
# ==============================================================================

fct_parse_arguments() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
		-h | --help)
			usage
			exit 0
			;;
		-V | --version)
			printf '%s\n' "${SCRIPT_NAME} v${SCRIPT_VERSION}"
			exit 0
			;;
		-v | --verbose)
			VERBOSE=1
			shift
			;;
		-n | --dry-run)
			DRY_RUN=1
			shift
			;;
		-f | --force)
			FORCE=1
			shift
			;;
		--no-color)
			NO_COLOR="1"
			shift
			;;
		-*)
			log_error "Unknown option: $1"
			usage
			exit 2
			;;
		*)
			log_error "Unexpected argument: $1"
			usage
			exit 2
			;;
		esac
	done
}

# ==============================================================================
# Main logic
# ==============================================================================

fct_execute() {
	local cwd clone_name parent_dir

	cwd="$(pwd)"
	clone_name="$(basename "$cwd")"
	parent_dir="$(dirname "$cwd")"

	log_debug "Current directory: ${cwd}"
	log_debug "Clone name: ${clone_name}"
	log_debug "Parent directory: ${parent_dir}"

	# Verify we're in a git repo
	if ! git rev-parse --git-dir >/dev/null 2>&1; then
		log_error "Not in a git repository"
		exit 1
	fi

	# Check for uncommitted changes
	if [[ -n "$(git status --porcelain 2>/dev/null)" ]]; then
		log_warn "Warning: You have uncommitted changes:"
		git status --short >&2
		echo "" >&2

		if [[ "${FORCE}" -eq 0 ]]; then
			if ! gum confirm "Delete anyway?"; then
				log_info "Aborted"
				exit 1
			fi
		else
			log_warn "Force mode: proceeding despite uncommitted changes"
		fi
	fi

	# Check for unpushed commits
	local unpushed
	unpushed="$(git log --oneline "@{upstream}..HEAD" 2>/dev/null)" || true
	if [[ -n "${unpushed}" ]]; then
		log_warn "Warning: You have unpushed commits:"
		echo "${unpushed}" >&2
		echo "" >&2

		if [[ "${FORCE}" -eq 0 ]]; then
			if ! gum confirm "Delete anyway?"; then
				log_info "Aborted"
				exit 1
			fi
		else
			log_warn "Force mode: proceeding despite unpushed commits"
		fi
	fi

	# Final confirmation
	if [[ "${FORCE}" -eq 0 ]]; then
		if ! gum confirm "Remove clone '${clone_name}'?"; then
			log_info "Aborted"
			exit 1
		fi
	fi

	if [[ "${DRY_RUN}" -eq 1 ]]; then
		log_info "[DRY-RUN] Would execute:"
		log_info "  cd ${parent_dir}"
		log_info "  rm -rf ${clone_name}"
		return 0
	fi

	# Perform deletion from parent directory
	# Note: The calling wrapper function handles the cd
	rm -rf "${cwd}"
	log_info "Removed ${clone_name}"

	# Output status for wrapper to know deletion succeeded
	printf 'deleted\n'
}

# ==============================================================================
# Main
# ==============================================================================

main() {
	fct_parse_arguments "$@"
	fct_execute
}

main "$@"
