#!/usr/bin/env bash
#
# ==============================================================================
# run-script - Universal script runner
# ==============================================================================
# Finds and executes scripts from predefined directories.
# Auto-detects file type and runs with appropriate interpreter.
# ==============================================================================

readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_AUTHOR="Pascal Andy"
readonly SCRIPT_DESCRIPTION="Find and execute scripts from predefined directories."

readonly SCRIPT_NAME="${BASH_SOURCE[0]##*/}"

# ==============================================================================
# Configuration - Search directories
# ==============================================================================

SEARCH_DIRS=(
  "$HOME/Documents/github_local/forzr/SKILLS"
  "$HOME/Documents/github_firepress/yourock2/flows"
)

# Extensions to try, in order of priority
EXTENSIONS=(".py" ".sh" "")

# ==============================================================================
# Runtime options
# ==============================================================================

VERBOSE=0
DRY_RUN=0
NO_COLOR="${NO_COLOR:-}"

# ==============================================================================
# Strict mode
# ==============================================================================

set -euo pipefail

# ==============================================================================
# Logging
# ==============================================================================

fct_ansi() {
  local code="${1}"
  if [[ -t 2 && -z "${NO_COLOR}" ]]; then
    printf '\033[%sm' "${code}"
  fi
}

log_info() {
  local reset="" prefix=""
  if [[ -t 2 && -z "${NO_COLOR}" ]]; then
    prefix="$(fct_ansi '32')"
    reset="$(fct_ansi '0')"
  fi
  printf '%s%s%s\n' "${prefix}" "$*" "${reset}" >&2
}

log_warn() {
  local reset="" prefix=""
  if [[ -t 2 && -z "${NO_COLOR}" ]]; then
    prefix="$(fct_ansi '33')"
    reset="$(fct_ansi '0')"
  fi
  printf '%s%s%s\n' "${prefix}" "$*" "${reset}" >&2
}

log_error() {
  local reset="" prefix=""
  if [[ -t 2 && -z "${NO_COLOR}" ]]; then
    prefix="$(fct_ansi '31')"
    reset="$(fct_ansi '0')"
  fi
  printf '%s%s%s\n' "${prefix}" "$*" "${reset}" >&2
}

log_debug() {
  if [[ "${VERBOSE}" -eq 1 ]]; then
    local reset="" prefix=""
    if [[ -t 2 && -z "${NO_COLOR}" ]]; then
      prefix="$(fct_ansi '36')"
      reset="$(fct_ansi '0')"
    fi
    printf '%s[DEBUG] %s%s\n' "${prefix}" "$*" "${reset}" >&2
  fi
}

# ==============================================================================
# Usage
# ==============================================================================

usage() {
  cat << EOF
${SCRIPT_NAME} v${SCRIPT_VERSION}
${SCRIPT_DESCRIPTION}
Author: ${SCRIPT_AUTHOR}

Usage:
  ${SCRIPT_NAME} [options] <script_name> [script_args...]

Arguments:
  <script_name>    Name of script to find (with or without extension)
  [script_args]    Arguments to pass to the script

Options:
  -h, --help       Show this help and exit
  -V, --version    Show version and exit
  -v, --verbose    Enable debug logging
  -n, --dry-run    Show what would be executed without running
      --no-color   Disable colored output
  -l, --list       List all available scripts

Search directories:
$(for dir in "${SEARCH_DIRS[@]}"; do echo "  - ${dir}"; done)

Execution rules:
  .py files  -> uv run <script>
  .sh files  -> bash <script>
  other      -> ./<script> (must be executable)

Examples:
  ${SCRIPT_NAME} transcript --help     # Find and run transcript.py or .sh
  ${SCRIPT_NAME} -n backup             # Dry-run: show what would execute
  ${SCRIPT_NAME} -l                    # List all available scripts
EOF
}

# ==============================================================================
# Argument parsing
# ==============================================================================

SCRIPT_TO_RUN=""
SCRIPT_ARGS=()
LIST_MODE=0

fct_parse_arguments() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h | --help)
        usage
        exit 0
        ;;
      -V | --version)
        printf '%s\n' "${SCRIPT_NAME} v${SCRIPT_VERSION}"
        exit 0
        ;;
      -v | --verbose)
        VERBOSE=1
        shift
        ;;
      -n | --dry-run)
        DRY_RUN=1
        shift
        ;;
      -l | --list)
        LIST_MODE=1
        shift
        ;;
      --no-color)
        NO_COLOR="1"
        shift
        ;;
      -*)
        log_error "Unknown option: $1"
        usage
        exit 2
        ;;
      *)
        # First positional arg is script name, rest are script args
        if [[ -z "${SCRIPT_TO_RUN}" ]]; then
          SCRIPT_TO_RUN="$1"
        else
          SCRIPT_ARGS+=("$1")
        fi
        shift
        ;;
    esac
  done
}

# ==============================================================================
# Script discovery
# ==============================================================================

fct_list_scripts() {
  log_info "Available scripts:"
  echo ""
  
  for dir in "${SEARCH_DIRS[@]}"; do
    if [[ -d "${dir}" ]]; then
      echo "  ${dir}:"
      # Find all .py and .sh files, show relative names
      while IFS= read -r script; do
        local rel_path="${script#"${dir}/"}"
        echo "    - ${rel_path}"
      done < <(find "${dir}" -maxdepth 4 -type f \( -name "*.py" -o -name "*.sh" \) 2>/dev/null | sort)
      echo ""
    else
      log_warn "  ${dir}: (not found)"
    fi
  done
}

fct_find_script() {
  local script_name="${1}"
  local matches=()

  for dir in "${SEARCH_DIRS[@]}"; do
    [[ -d "${dir}" ]] || continue
    
    for ext in "${EXTENSIONS[@]}"; do
      local search_name="${script_name}${ext}"
      while IFS= read -r match; do
        [[ -n "${match}" ]] && matches+=("${match}")
      done < <(find "${dir}" -maxdepth 4 -name "${search_name}" -type f 2>/dev/null)
    done
  done

  # Return matches via global variable (bash limitation)
  FOUND_MATCHES=("${matches[@]}")
}

# ==============================================================================
# Script execution
# ==============================================================================

fct_execute_script() {
  local script_path="${1}"
  shift
  local args=("$@")

  local script_dir
  script_dir="$(dirname "${script_path}")"
  local script_basename
  script_basename="$(basename "${script_path}")"

  local cmd=""
  local cmd_args=()

  case "${script_basename}" in
    *.py)
      cmd="uv"
      cmd_args=("run" "${script_basename}" "${args[@]}")
      ;;
    *.sh)
      cmd="bash"
      cmd_args=("./${script_basename}" "${args[@]}")
      ;;
    *)
      cmd="./${script_basename}"
      cmd_args=("${args[@]}")
      ;;
  esac

  if [[ "${DRY_RUN}" -eq 1 ]]; then
    log_info "[DRY-RUN] Would execute:"
    log_info "  Directory: ${script_dir}"
    if [[ "${cmd}" == "./${script_basename}" ]]; then
      log_info "  Command: ${cmd} ${cmd_args[*]:-}"
    else
      log_info "  Command: ${cmd} ${cmd_args[*]}"
    fi
    return 0
  fi

  log_debug "Executing: ${script_path}"
  log_debug "Working dir: ${script_dir}"

  # Execute in subshell to preserve current directory
  (cd "${script_dir}" && "${cmd}" "${cmd_args[@]}")
}

# ==============================================================================
# Main logic
# ==============================================================================

fct_execute() {
  # List mode
  if [[ "${LIST_MODE}" -eq 1 ]]; then
    fct_list_scripts
    return 0
  fi

  # Require script name
  if [[ -z "${SCRIPT_TO_RUN}" ]]; then
    log_error "Missing required argument: <script_name>"
    echo ""
    usage
    exit 2
  fi

  # Find matching scripts
  FOUND_MATCHES=()
  fct_find_script "${SCRIPT_TO_RUN}"

  # No matches
  if [[ ${#FOUND_MATCHES[@]} -eq 0 ]]; then
    log_error "Script not found: ${SCRIPT_TO_RUN}"
    log_error "Searched in:"
    for dir in "${SEARCH_DIRS[@]}"; do
      log_error "  - ${dir}"
    done
    exit 1
  fi

  # Single match - execute directly
  if [[ ${#FOUND_MATCHES[@]} -eq 1 ]]; then
    fct_execute_script "${FOUND_MATCHES[0]}" "${SCRIPT_ARGS[@]}"
    return $?
  fi

  # Multiple matches - prompt user
  log_warn "Multiple scripts found:"
  for i in "${!FOUND_MATCHES[@]}"; do
    echo "  $((i + 1)). ${FOUND_MATCHES[${i}]}" >&2
  done

  if [[ "${DRY_RUN}" -eq 1 ]]; then
    log_info "[DRY-RUN] Would prompt for selection"
    return 0
  fi

  printf "Select [1-%d]: " "${#FOUND_MATCHES[@]}" >&2
  read -r choice

  if [[ "${choice}" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#FOUND_MATCHES[@]} )); then
    local selected_index=$((choice - 1))
    fct_execute_script "${FOUND_MATCHES[${selected_index}]}" "${SCRIPT_ARGS[@]}"
    return $?
  else
    log_error "Invalid selection"
    exit 1
  fi
}

# ==============================================================================
# Main
# ==============================================================================

main() {
  fct_parse_arguments "$@"
  fct_execute
}

main "$@"
