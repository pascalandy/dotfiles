#!/usr/bin/env bash
#
# ==============================================================================
# git-clone-branch-out - Create a parallel clone for feature development
# ==============================================================================
# Creates a new git clone with reference to current repo for space savings,
# then creates a feature branch. Outputs the clone path for the calling
# wrapper function to cd into.
# ==============================================================================

readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_AUTHOR="Pascal Andy"
readonly SCRIPT_DESCRIPTION="Create a parallel clone and branch for development."

readonly SCRIPT_NAME="${BASH_SOURCE[0]##*/}"

# ==============================================================================
# Runtime options
# ==============================================================================

VERBOSE=0
DRY_RUN=0
NO_COLOR="${NO_COLOR:-}"

# ==============================================================================
# Strict mode
# ==============================================================================

set -euo pipefail

# ==============================================================================
# Logging (to stderr so stdout can be used for clone path)
# ==============================================================================

fct_ansi() {
	local code="${1}"
	if [[ -t 2 && -z "${NO_COLOR}" ]]; then
		printf '\033[%sm' "${code}"
	fi
}

log_info() {
	local reset="" prefix=""
	if [[ -t 2 && -z "${NO_COLOR}" ]]; then
		prefix="$(fct_ansi '32')"
		reset="$(fct_ansi '0')"
	fi
	printf '%s%s%s\n' "${prefix}" "$*" "${reset}" >&2
}

log_error() {
	local reset="" prefix=""
	if [[ -t 2 && -z "${NO_COLOR}" ]]; then
		prefix="$(fct_ansi '31')"
		reset="$(fct_ansi '0')"
	fi
	printf '%s%s%s\n' "${prefix}" "$*" "${reset}" >&2
}

log_debug() {
	if [[ "${VERBOSE}" -eq 1 ]]; then
		local reset="" prefix=""
		if [[ -t 2 && -z "${NO_COLOR}" ]]; then
			prefix="$(fct_ansi '36')"
			reset="$(fct_ansi '0')"
		fi
		printf '%s[DEBUG] %s%s\n' "${prefix}" "$*" "${reset}" >&2
	fi
}

# ==============================================================================
# Usage
# ==============================================================================

usage() {
	cat <<EOF
${SCRIPT_NAME} v${SCRIPT_VERSION}
${SCRIPT_DESCRIPTION}
Author: ${SCRIPT_AUTHOR}

Usage:
  ${SCRIPT_NAME} [options] <branch-name>

Arguments:
  <branch-name>    Name for the new branch (will be prefixed with sj/)

Options:
  -h, --help       Show this help and exit
  -V, --version    Show version and exit
  -v, --verbose    Enable debug logging
  -n, --dry-run    Show what would be done without executing
      --no-color   Disable colored output

Description:
  Creates a clone of the current repository at ../<repo>-<branch>
  using git reference for space savings. Then creates branch sj/<branch-name>
  based on a branch selected via fzf (defaults to main).

  The clone path is output to stdout for use by a wrapper function.

Examples:
  ${SCRIPT_NAME} feature-auth
  ${SCRIPT_NAME} -v bugfix-login
  ${SCRIPT_NAME} -n test-feature
EOF
}

# ==============================================================================
# Argument parsing
# ==============================================================================

BRANCH_NAME=""

fct_parse_arguments() {
	local positional=()

	while [[ $# -gt 0 ]]; do
		case "$1" in
		-h | --help)
			usage
			exit 0
			;;
		-V | --version)
			printf '%s\n' "${SCRIPT_NAME} v${SCRIPT_VERSION}"
			exit 0
			;;
		-v | --verbose)
			VERBOSE=1
			shift
			;;
		-n | --dry-run)
			DRY_RUN=1
			shift
			;;
		--no-color)
			NO_COLOR="1"
			shift
			;;
		-*)
			log_error "Unknown option: $1"
			usage
			exit 2
			;;
		*)
			positional+=("$1")
			shift
			;;
		esac
	done

	if [[ ${#positional[@]} -eq 0 ]]; then
		log_error "Missing required argument: <branch-name>"
		usage
		exit 2
	fi

	BRANCH_NAME="${positional[0]}"
}

# ==============================================================================
# Main logic
# ==============================================================================

fct_execute() {
	local repo_name repo_url clone_path base_branch

	# Verify we're in a git repo
	if ! git rev-parse --git-dir >/dev/null 2>&1; then
		log_error "Not in a git repository"
		exit 1
	fi

	repo_name="$(basename "$PWD")"
	repo_url="$(git remote get-url origin 2>/dev/null)" || {
		log_error "No origin remote found"
		exit 1
	}
	clone_path="../${repo_name}-${BRANCH_NAME}"

	log_debug "Branch name: ${BRANCH_NAME}"
	log_debug "Repo name: ${repo_name}"
	log_debug "Clone path: ${clone_path}"

	# Check if clone path already exists
	if [[ -d "${clone_path}" ]]; then
		log_error "Directory already exists: ${clone_path}"
		exit 1
	fi

	# Select base branch via fzf (interactive mode only)
	if [[ -t 0 ]]; then
		base_branch="$(git branch -r --format='%(refname:short)' | sed 's|origin/||' | fzf --height=20 --prompt='Select base branch: ' --query="main" 2>/dev/null)" || true
	fi

	# Default to main if fzf cancelled or non-interactive
	if [[ -z "${base_branch:-}" ]]; then
		base_branch="main"
	fi

	log_debug "Base branch: ${base_branch}"

	if [[ "${DRY_RUN}" -eq 1 ]]; then
		log_info "[DRY-RUN] Would execute:"
		log_info "  git clone --reference $PWD ${repo_url} ${clone_path}"
		log_info "  git checkout ${base_branch}"
		log_info "  git checkout -b sj/${BRANCH_NAME}"
		log_info "Clone would be at: ${clone_path}"
		return 0
	fi

	log_info "Creating clone at ${clone_path} from ${base_branch}..."

	# Clone with reference to current repo for speed/space savings
	git clone --reference "$PWD" "${repo_url}" "${clone_path}"

	# Set up branch in the clone
	(
		cd "${clone_path}"
		git checkout "${base_branch}"
		git checkout -b "sj/${BRANCH_NAME}"
	)

	log_info "Created clone at ${clone_path} on branch sj/${BRANCH_NAME} (based on ${base_branch})"

	# Output clone path to stdout (for wrapper to cd into)
	printf '%s\n' "${clone_path}"
}

# ==============================================================================
# Main
# ==============================================================================

main() {
	fct_parse_arguments "$@"
	fct_execute
}

main "$@"
